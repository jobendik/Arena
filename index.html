<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blockline Arena - Enhanced Weapon System</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            overflow: hidden; 
            background: #000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        #game-container { width: 100vw; height: 100vh; }
        
        /* HUD Styles */
        #hud {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }
        
        #health-bar-container {
            position: absolute;
            bottom: 40px;
            left: 20px;
            width: 250px;
            height: 25px;
            background: rgba(0,0,0,0.7);
            border: 2px solid #22c55e;
            box-shadow: 0 0 10px rgba(34, 197, 94, 0.5);
        }
        
        #health-bar {
            height: 100%;
            width: 100%;
            background: linear-gradient(90deg, #22c55e, #4ade80);
            transition: width 0.2s, background-color 0.3s;
            box-shadow: inset 0 0 10px rgba(255,255,255,0.3);
        }
        
        #health-label {
            position: absolute;
            bottom: 68px;
            left: 20px;
            color: #22c55e;
            font-size: 12px;
            font-weight: bold;
            text-shadow: 0 0 5px rgba(34, 197, 94, 0.8);
        }
        
        #armor-bar-container {
            position: absolute;
            bottom: 75px;
            left: 20px;
            width: 250px;
            height: 15px;
            background: rgba(0,0,0,0.7);
            border: 2px solid #3b82f6;
            box-shadow: 0 0 10px rgba(59, 130, 246, 0.5);
        }
        
        #armor-bar {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #3b82f6, #60a5fa);
            transition: width 0.2s;
            box-shadow: inset 0 0 10px rgba(255,255,255,0.3);
        }
        
        #armor-label {
            position: absolute;
            bottom: 93px;
            left: 20px;
            color: #3b82f6;
            font-size: 10px;
            font-weight: bold;
            text-shadow: 0 0 5px rgba(59, 130, 246, 0.8);
        }
        
        #stamina-bar-container {
            position: absolute;
            bottom: 110px;
            left: 20px;
            width: 250px;
            height: 10px;
            background: rgba(0,0,0,0.7);
            border: 2px solid #f59e0b;
            box-shadow: 0 0 10px rgba(245, 158, 11, 0.5);
        }
        
        #stamina-bar {
            height: 100%;
            width: 100%;
            background: linear-gradient(90deg, #f59e0b, #fbbf24);
            transition: width 0.1s;
            box-shadow: inset 0 0 10px rgba(255,255,255,0.3);
        }
        
        #stamina-label {
            position: absolute;
            bottom: 123px;
            left: 20px;
            color: #f59e0b;
            font-size: 10px;
            font-weight: bold;
            text-shadow: 0 0 5px rgba(245, 158, 11, 0.8);
        }
        
        #ammo-display {
            position: absolute;
            bottom: 40px;
            right: 40px;
            color: #fff;
            font-size: 32px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        
        #ammo-display.low { color: #f59e0b; }
        #ammo-display.empty { color: #ef4444; animation: pulse 0.5s infinite; }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        #wave-display {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #fff;
            font-size: 24px;
            font-weight: bold;
            text-align: center;
            text-shadow: 0 0 20px rgba(0, 255, 255, 0.8), 0 0 40px rgba(0, 255, 255, 0.4);
            background: linear-gradient(90deg, #00ffff, #ff00ff, #00ffff);
            background-size: 200% auto;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: waveGradient 3s linear infinite;
        }
        
        @keyframes waveGradient {
            0% { background-position: 0% center; }
            100% { background-position: 200% center; }
        }
        
        #score-display {
            position: absolute;
            top: 60px;
            left: 50%;
            transform: translateX(-50%);
            color: #fbbf24;
            font-size: 36px;
            font-weight: bold;
            text-shadow: 0 0 20px rgba(251, 191, 36, 0.8), 0 0 40px rgba(251, 191, 36, 0.4);
            transition: transform 0.1s, text-shadow 0.1s;
        }
        
        #score-display.pop {
            transform: translateX(-50%) scale(1.3);
            text-shadow: 0 0 30px rgba(251, 191, 36, 1), 0 0 60px rgba(251, 191, 36, 0.6);
        }
        
        #score-label {
            position: absolute;
            top: 48px;
            left: 50%;
            transform: translateX(-50%);
            color: #9ca3af;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }
        
        .crosshair-line {
            position: absolute;
            background: #fff;
        }
        
        #hitmarker {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            opacity: 0;
            pointer-events: none;
            transition: transform 0.05s;
        }
        
        #damage-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, transparent 0%, rgba(255,0,0,0.4) 100%);
            opacity: 0;
            transition: opacity 0.1s;
            pointer-events: none;
        }
        
        #low-health-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, transparent 30%, rgba(255,0,0,0.3) 100%);
            opacity: 0;
            pointer-events: none;
        }
        
        #message-display {
            position: absolute;
            top: 30%;
            left: 50%;
            transform: translateX(-50%);
            color: #fff;
            font-size: 64px;
            font-weight: bold;
            text-shadow: 0 0 30px rgba(0, 255, 255, 1), 0 0 60px rgba(255, 0, 255, 0.8);
            opacity: 0;
            transition: opacity 0.3s, transform 0.3s;
            background: linear-gradient(90deg, #00ffff, #ff00ff, #ffff00);
            background-size: 300% auto;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: messageGradient 2s linear infinite;
        }
        
        @keyframes messageGradient {
            0% { background-position: 0% center; }
            100% { background-position: 300% center; }
        }
        
        #reload-indicator {
            position: absolute;
            bottom: 80px;
            right: 40px;
            color: #f59e0b;
            font-size: 14px;
            font-weight: bold;
            opacity: 0;
            text-shadow: 0 0 10px rgba(245, 158, 11, 0.8);
            animation: reloadPulse 0.5s ease-in-out infinite;
        }
        
        @keyframes reloadPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        #enemies-remaining {
            position: absolute;
            top: 45px;
            right: 20px;
            color: #9ca3af;
            font-size: 14px;
        }
        
        #powerup-indicator {
            position: absolute;
            bottom: 140px;
            left: 20px;
            color: #a855f7;
            font-size: 14px;
            font-weight: bold;
            opacity: 0;
            text-shadow: 0 0 10px rgba(168, 85, 247, 0.8);
        }
        
        /* Pause Menu */
        #pause-menu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #fff;
            pointer-events: auto;
            z-index: 150;
        }
        
        #pause-menu h1 {
            font-size: 72px;
            margin-bottom: 50px;
            background: linear-gradient(90deg, #00ffff, #ff00ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: none;
        }
        
        #pause-menu button {
            padding: 15px 50px;
            font-size: 24px;
            margin: 10px;
            border: 2px solid;
            background: transparent;
            color: #fff;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        #resume-btn {
            border-color: #22c55e;
        }
        
        #resume-btn:hover {
            background: #22c55e;
            box-shadow: 0 0 20px rgba(34, 197, 94, 0.5);
        }
        
        #quit-btn {
            border-color: #ef4444;
        }
        
        #quit-btn:hover {
            background: #ef4444;
            box-shadow: 0 0 20px rgba(239, 68, 68, 0.5);
        }
        
        #game-over {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #fff;
            pointer-events: auto;
        }
        
        #game-over h1 {
            font-size: 64px;
            color: #ef4444;
            margin-bottom: 30px;
        }
        
        #game-over .stats {
            font-size: 20px;
            margin-bottom: 40px;
            text-align: center;
            line-height: 1.8;
        }
        
        #restart-btn {
            padding: 15px 40px;
            font-size: 24px;
            background: #3b82f6;
            border: none;
            color: #fff;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        #restart-btn:hover {
            background: #2563eb;
        }
        
        #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #fff;
            pointer-events: auto;
            z-index: 200;
        }
        
        #start-screen h1 {
            font-size: 72px;
            color: #3b82f6;
            margin-bottom: 20px;
            text-transform: uppercase;
            letter-spacing: 8px;
        }
        
        #start-screen p {
            font-size: 18px;
            margin-bottom: 40px;
            color: #9ca3af;
        }
        
        #start-screen .controls {
            font-size: 14px;
            color: #6b7280;
            margin-top: 30px;
            text-align: center;
            line-height: 2;
        }
        
        #start-btn {
            padding: 20px 60px;
            font-size: 28px;
            background: #10b981;
            border: none;
            color: #fff;
            cursor: pointer;
            transition: background 0.2s, transform 0.1s;
        }
        
        #start-btn:hover {
            background: #059669;
            transform: scale(1.05);
        }
    </style>
</head>
<body>
    <div id="game-container"></div>
    
    <div id="hud">
        <div id="health-label">HEALTH</div>
        <div id="health-bar-container">
            <div id="health-bar"></div>
        </div>
        
        <div id="armor-label">ARMOR</div>
        <div id="armor-bar-container">
            <div id="armor-bar"></div>
        </div>
        
        <div id="stamina-label">STAMINA</div>
        <div id="stamina-bar-container">
            <div id="stamina-bar"></div>
        </div>
        
        <div id="ammo-display">30 / 90</div>
        <div id="reload-indicator">RELOADING...</div>
        
        <div id="wave-display">WAVE 1</div>
        <div id="score-label">SCORE</div>
        <div id="score-display">0</div>
        <div id="enemies-remaining">Enemies: 0</div>
        
        <div id="powerup-indicator"></div>
        
        <div id="crosshair">
            <div class="crosshair-line" id="cross-top"></div>
            <div class="crosshair-line" id="cross-bottom"></div>
            <div class="crosshair-line" id="cross-left"></div>
            <div class="crosshair-line" id="cross-right"></div>
        </div>
        
        <div id="hitmarker">
            <svg width="20" height="20" viewBox="0 0 20 20">
                <line x1="4" y1="4" x2="8" y2="8" stroke="white" stroke-width="2"/>
                <line x1="16" y1="4" x2="12" y2="8" stroke="white" stroke-width="2"/>
                <line x1="4" y1="16" x2="8" y2="12" stroke="white" stroke-width="2"/>
                <line x1="16" y1="16" x2="12" y2="12" stroke="white" stroke-width="2"/>
            </svg>
        </div>
        
        <div id="damage-overlay"></div>
        <div id="low-health-overlay"></div>
        <div id="message-display"></div>
        
        <div id="pause-menu">
            <h1>PAUSED</h1>
            <button id="resume-btn">RESUME</button>
            <button id="quit-btn">QUIT TO MENU</button>
        </div>
        
        <div id="game-over">
            <h1>GAME OVER</h1>
            <div class="stats">
                <div>Waves Survived: <span id="final-waves">0</span></div>
                <div>Enemies Killed: <span id="final-kills">0</span></div>
                <div>Accuracy: <span id="final-accuracy">0</span>%</div>
                <div>Time Survived: <span id="final-time">0:00</span></div>
                <div>Final Score: <span id="final-score">0</span></div>
            </div>
            <button id="restart-btn">PLAY AGAIN</button>
        </div>
    </div>
    
    <div id="start-screen">
        <h1>Blockline Arena</h1>
        <p>Wave-based survival shooter â€¢ Enhanced Weapon System</p>
        <button id="start-btn">START GAME</button>
        <div class="controls">
            WASD - Move | SHIFT - Sprint | SPACE - Jump<br>
            MOUSE - Aim | LEFT CLICK - Shoot | R - Reload
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script>
        // ===== ENHANCED WEAPON CONFIGURATION =====
        const WEAPON_CONFIG = {
            damage: 25,
            fireRate: 10,
            magSize: 30,
            reserveAmmo: 90,
            reloadTime: 1.8,
            
            recoil: {
                pitchAmount: 0.8,
                pitchRandom: 0.15,
                yawAmount: 0.3,
                yawRandom: 0.4,
                recoverySpeed: 12,
                recoveryDelay: 0.05,
                maxPitch: 8,
                maxYaw: 3,
                kickBackZ: 0.08,
                kickBackRecovery: 18,
                kickRotationX: 3,
                shakeIntensity: 0.003,
                shakeDuration: 0.08,
                shakeDecay: 0.85
            },
            
            spread: {
                base: 0.006,
                move: 0.022,
                sprint: 0.045,
                air: 0.035,
                perShot: 0.012,
                maxBloom: 0.06,
                bloomRecovery: 8,
                firstShotBonus: 0.5
            },
            
            sprayPattern: {
                enabled: true,
                pattern: [
                    [0, 0], [0.3, 0], [0.5, 0], [0.7, 0.1], [0.8, -0.1],
                    [0.9, 0.15], [1.0, -0.2], [1.0, 0.25], [0.9, -0.3],
                    [0.8, 0.3], [0.7, -0.25], [0.6, 0.2]
                ],
                patternScale: 0.015,
                resetTime: 0.3
            },
            
            muzzle: {
                flashDuration: 0.045,
                flashScale: { min: 0.8, max: 1.2 },
                lightIntensity: 3,
                lightRange: 8,
                lightColor: 0xffaa44,
                smokeParticles: 4,
                smokeDuration: 0.25,
                smokeSpeed: 2
            },
            
            screen: {
                fovPunch: 0.8,
                fovPunchRecovery: 15,
                maxFovPunch: 3,
                shakeIntensity: 0.012,
                shakeDecay: 0.88,
                // Chromatic aberration
                chromaIntensity: 0.008,
                chromaDecay: 0.92,
                maxChroma: 0.025
            },
            
            animation: {
                baseX: 0.25,
                baseY: -0.2,
                baseZ: -0.5,
                swayAmount: 0.003,
                swayRecovery: 12,
                sprintOffsetX: -0.08,
                sprintOffsetY: 0.12,
                sprintRotZ: -0.3,
                sprintLerpSpeed: 8,
                bobInfluence: 0.6,
                reloadDipY: 0.35,
                reloadRotX: 0.4,
                reloadLerpSpeed: 6
            }
        };

        // ===== GAME CONFIGURATION =====
        const CONFIG = {
            player: {
                walkSpeed: 7,
                sprintSpeed: 12,
                jumpForce: 10,
                gravity: 28,
                groundAccel: 60,
                groundDecel: 50,
                airAccel: 15,
                airDecel: 5,
                friction: 8,
                coyoteTime: 0.12,
                jumpBuffer: 0.1,
                jumpCutMultiplier: 0.4,
                stepHeight: 0.35,
                height: 1.8,
                maxHealth: 100,
                maxArmor: 100,
                maxStamina: 100,
                staminaDrain: 20,
                staminaRegen: 18
            },
            
            camera: {
                baseFOV: 90,
                sprintFOV: 100,
                fovLerpSpeed: 8,
                bobFrequency: 14,
                bobAmplitudeY: 0.035,
                bobAmplitudeX: 0.015,
                breathFrequency: 1.2,
                breathAmplitude: 0.008,
                landingSquash: 0.04,
                jumpStretch: 0.02,
                mouseSensitivity: 0.002
            },
            
            arena: {
                size: 60,
                wallHeight: 8
            }
        };

        // ===== GAME STATE =====
        let gameState = {
            running: false,
            paused: false,
            wave: 1,
            score: 0,
            kills: 0,
            shotsFired: 0,
            shotsHit: 0,
            timeStarted: 0,
            waveInProgress: false,
            betweenWaves: false
        };

        // ===== THREE.JS SETUP =====
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(CONFIG.camera.baseFOV, window.innerWidth / window.innerHeight, 0.1, 1000);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2;
        renderer.outputEncoding = THREE.sRGBEncoding;
        document.getElementById('game-container').appendChild(renderer.domElement);

        // ===== SKY SHADER =====
        const skyGeo = new THREE.SphereGeometry(400, 32, 32);
        const skyMat = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0 },
                topColor: { value: new THREE.Color(0x0a0a1a) },
                bottomColor: { value: new THREE.Color(0x1a0a2e) },
                sunColor: { value: new THREE.Color(0xff4400) },
                sunPosition: { value: new THREE.Vector3(100, 20, -100) }
            },
            vertexShader: `
                varying vec3 vWorldPosition;
                void main() {
                    vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                    vWorldPosition = worldPosition.xyz;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform float time;
                uniform vec3 topColor;
                uniform vec3 bottomColor;
                uniform vec3 sunColor;
                uniform vec3 sunPosition;
                varying vec3 vWorldPosition;
                
                float random(vec2 st) {
                    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
                }
                
                void main() {
                    vec3 viewDirection = normalize(vWorldPosition - cameraPosition);
                    float heightFactor = (viewDirection.y + 1.0) * 0.5;
                    vec3 skyColor = mix(bottomColor, topColor, pow(heightFactor, 0.5));
                    
                    vec3 sunDir = normalize(sunPosition);
                    float sunDot = max(0.0, dot(viewDirection, sunDir));
                    skyColor += sunColor * (pow(sunDot, 64.0) * 2.0 + pow(sunDot, 8.0) * 0.3);
                    
                    float aurora = sin(viewDirection.x * 3.0 + time * 0.5) * 
                                   sin(viewDirection.z * 2.0 + time * 0.3) * 0.5 + 0.5;
                    skyColor += vec3(0.2, 0.5, 1.0) * aurora * pow(heightFactor, 2.0) * 0.15;
                    
                    vec2 starUV = viewDirection.xz / (viewDirection.y + 0.1);
                    float stars = step(0.998, random(floor(starUV * 200.0))) * heightFactor * 0.8;
                    float twinkle = sin(time * 3.0 + random(floor(starUV * 200.0)) * 100.0) * 0.5 + 0.5;
                    skyColor += vec3(1.0) * stars * twinkle;
                    
                    gl_FragColor = vec4(skyColor, 1.0);
                }
            `,
            side: THREE.BackSide
        });
        scene.add(new THREE.Mesh(skyGeo, skyMat));

        // ===== POST-PROCESSING WITH CHROMATIC ABERRATION =====
        const composer = new THREE.EffectComposer(renderer);
        composer.addPass(new THREE.RenderPass(scene, camera));
        
        const bloomPass = new THREE.UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight),
            0.7, 0.4, 0.85
        );
        composer.addPass(bloomPass);
        
        // Chromatic Aberration Shader
        const ChromaticAberrationShader = {
            uniforms: {
                tDiffuse: { value: null },
                amount: { value: 0.0 },
                angle: { value: 0.0 }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform sampler2D tDiffuse;
                uniform float amount;
                uniform float angle;
                varying vec2 vUv;
                
                void main() {
                    vec2 offset = amount * vec2(cos(angle), sin(angle));
                    
                    // Radial chromatic aberration - stronger at edges
                    vec2 center = vUv - 0.5;
                    float dist = length(center);
                    vec2 dir = normalize(center + 0.0001);
                    
                    // Sample each color channel with offset
                    float r = texture2D(tDiffuse, vUv + dir * offset * dist).r;
                    float g = texture2D(tDiffuse, vUv).g;
                    float b = texture2D(tDiffuse, vUv - dir * offset * dist).b;
                    
                    gl_FragColor = vec4(r, g, b, 1.0);
                }
            `
        };
        
        const chromaPass = new THREE.ShaderPass(ChromaticAberrationShader);
        composer.addPass(chromaPass);
        
        // Vignette
        const vignettePass = new THREE.ShaderPass({
            uniforms: {
                tDiffuse: { value: null },
                darkness: { value: 1.0 },
                offset: { value: 1.0 }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform sampler2D tDiffuse;
                uniform float darkness;
                uniform float offset;
                varying vec2 vUv;
                void main() {
                    vec4 texel = texture2D(tDiffuse, vUv);
                    vec2 uv = (vUv - vec2(0.5)) * vec2(offset);
                    texel.rgb *= pow(1.0 - dot(uv, uv), darkness);
                    gl_FragColor = texel;
                }
            `
        });
        composer.addPass(vignettePass);

        // ===== LIGHTING =====
        scene.add(new THREE.AmbientLight(0x1a1a3a, 0.3));
        
        const mainLight = new THREE.DirectionalLight(0xff6b35, 1.2);
        mainLight.position.set(30, 50, -30);
        mainLight.castShadow = true;
        mainLight.shadow.mapSize.width = 4096;
        mainLight.shadow.mapSize.height = 4096;
        mainLight.shadow.camera.near = 0.5;
        mainLight.shadow.camera.far = 150;
        mainLight.shadow.camera.left = -60;
        mainLight.shadow.camera.right = 60;
        mainLight.shadow.camera.top = 60;
        mainLight.shadow.camera.bottom = -60;
        scene.add(mainLight);
        
        scene.add(new THREE.DirectionalLight(0x4a9eff, 0.4).translateX(-30).translateY(20).translateZ(30));
        scene.add(new THREE.DirectionalLight(0xff4488, 0.6).translateY(10).translateZ(50));
        
        const pointLights = [];
        const centerLight = new THREE.PointLight(0xff3366, 2, 25);
        centerLight.position.set(0, 3, 0);
        scene.add(centerLight);
        pointLights.push({ light: centerLight, baseIntensity: 2, phase: 0 });
        
        const cornerColors = [0x00ffff, 0xff00ff, 0xffff00, 0x00ff88];
        [[20, 4, 20], [-20, 4, 20], [20, 4, -20], [-20, 4, -20]].forEach((pos, i) => {
            const light = new THREE.PointLight(cornerColors[i], 1.5, 30);
            light.position.set(...pos);
            scene.add(light);
            pointLights.push({ light, baseIntensity: 1.5, phase: i * 0.5 });
        });
        
        scene.fog = new THREE.FogExp2(0x0a0a1a, 0.012);

        // ===== PLAYER STATE =====
        const player = {
            position: new THREE.Vector3(0, CONFIG.player.height, 0),
            velocity: new THREE.Vector3(),
            rotation: { x: 0, y: 0 },
            health: CONFIG.player.maxHealth,
            armor: 0,
            stamina: CONFIG.player.maxStamina,
            onGround: true,
            isSprinting: false,
            coyoteTimer: 0,
            jumpBufferTimer: 0,
            isJumping: false,
            canCutJump: false,
            prevVelocity: new THREE.Vector3(),
            powerup: null,
            powerupTimer: 0,
            damageMultiplier: 1,
            speedMultiplier: 1,
            headBobTime: 0,
            currentFOV: CONFIG.camera.baseFOV,
            landingImpact: 0,
            jumpLift: 0
        };

        // ===== INPUT HANDLING =====
        const keys = {};
        const mouse = { x: 0, y: 0, buttons: {}, deltaX: 0, deltaY: 0 };

        document.addEventListener('keydown', (e) => {
            keys[e.code] = true;
            if (e.code === 'Space') player.jumpBufferTimer = CONFIG.player.jumpBuffer;
            if (e.code === 'KeyR' && gameState.running && !gameState.paused) tryReload();
            if (e.code === 'Escape' && gameState.running) togglePause();
        });

        document.addEventListener('keyup', (e) => {
            keys[e.code] = false;
            if (e.code === 'Space' && player.canCutJump && player.velocity.y > 0) {
                player.velocity.y *= CONFIG.player.jumpCutMultiplier;
                player.canCutJump = false;
            }
        });
        
        function togglePause() {
            gameState.paused = !gameState.paused;
            const pauseMenu = document.getElementById('pause-menu');
            if (gameState.paused) {
                pauseMenu.style.display = 'flex';
                document.exitPointerLock();
            } else {
                pauseMenu.style.display = 'none';
                renderer.domElement.requestPointerLock();
            }
        }

        document.addEventListener('mousemove', (e) => {
            if (document.pointerLockElement) {
                player.rotation.y -= e.movementX * CONFIG.camera.mouseSensitivity;
                player.rotation.x -= e.movementY * CONFIG.camera.mouseSensitivity;
                player.rotation.x = Math.max(-Math.PI * 0.49, Math.min(Math.PI * 0.49, player.rotation.x));
                mouse.deltaX = e.movementX;
                mouse.deltaY = e.movementY;
            }
        });

        document.addEventListener('mousedown', (e) => { mouse.buttons[e.button] = true; });
        document.addEventListener('mouseup', (e) => { mouse.buttons[e.button] = false; });

        // ===== WEAPON MODEL =====
        const weaponGroup = new THREE.Group();
        
        const weaponBody = new THREE.Mesh(
            new THREE.BoxGeometry(0.08, 0.12, 0.5),
            new THREE.MeshStandardMaterial({ color: 0x1a1a1a, metalness: 0.9, roughness: 0.3 })
        );
        weaponBody.position.set(0, 0, -0.15);
        weaponGroup.add(weaponBody);
        
        const barrel = new THREE.Mesh(
            new THREE.BoxGeometry(0.04, 0.04, 0.3),
            new THREE.MeshStandardMaterial({ color: 0x0a0a0a, metalness: 0.95, roughness: 0.2 })
        );
        barrel.position.set(0, 0.02, -0.45);
        weaponGroup.add(barrel);
        
        const handle = new THREE.Mesh(
            new THREE.BoxGeometry(0.06, 0.15, 0.08),
            new THREE.MeshStandardMaterial({ color: 0x2a2a2a, metalness: 0.7, roughness: 0.4 })
        );
        handle.position.set(0, -0.1, 0);
        handle.rotation.x = -0.2;
        weaponGroup.add(handle);
        
        const magazine = new THREE.Mesh(
            new THREE.BoxGeometry(0.04, 0.12, 0.06),
            new THREE.MeshStandardMaterial({ color: 0x3a3a3a, metalness: 0.8, roughness: 0.3 })
        );
        magazine.position.set(0, -0.12, -0.1);
        weaponGroup.add(magazine);
        
        const sight = new THREE.Mesh(
            new THREE.BoxGeometry(0.02, 0.04, 0.02),
            new THREE.MeshBasicMaterial({ color: 0x00ff00 })
        );
        sight.position.set(0, 0.08, -0.2);
        weaponGroup.add(sight);
        
        weaponGroup.position.set(0.25, -0.2, -0.5);
        camera.add(weaponGroup);
        scene.add(camera);

        // Muzzle flashes
        const muzzleFlash = new THREE.Mesh(
            new THREE.SphereGeometry(0.08, 8, 8),
            new THREE.MeshBasicMaterial({ color: 0xffaa00, transparent: true, opacity: 0 })
        );
        muzzleFlash.position.set(0, 0.02, -0.6);
        weaponGroup.add(muzzleFlash);
        
        const muzzleFlash2 = new THREE.Mesh(
            new THREE.BoxGeometry(0.15, 0.15, 0.05),
            new THREE.MeshBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0 })
        );
        muzzleFlash2.position.set(0, 0.02, -0.62);
        weaponGroup.add(muzzleFlash2);
        
        // Muzzle light
        const muzzleLight = new THREE.PointLight(WEAPON_CONFIG.muzzle.lightColor, 0, WEAPON_CONFIG.muzzle.lightRange);
        muzzleLight.position.copy(muzzleFlash.position);
        weaponGroup.add(muzzleLight);

        // ===== WEAPON SYSTEM STATE =====
        const weaponState = {
            currentMag: WEAPON_CONFIG.magSize,
            reserveAmmo: WEAPON_CONFIG.reserveAmmo,
            isReloading: false,
            reloadTimer: 0,
            lastShotTime: 0,
            shotsFiredInBurst: 0,
            timeSinceLastShot: 0,
            
            // Recoil
            recoilPitch: 0,
            recoilYaw: 0,
            recoilRecoveryTimer: 0,
            weaponKickZ: 0,
            weaponKickRotX: 0,
            microShake: { x: 0, y: 0, timer: 0 },
            
            // Spread
            currentBloom: 0,
            
            // Screen effects
            fovPunch: 0,
            cameraShake: { x: 0, y: 0, intensity: 0 },
            chromaIntensity: 0,
            
            // Animation
            weaponSwayX: 0,
            weaponSwayY: 0,
            sprintBlend: 0,
            reloadBlend: 0,
            
            // Smoke
            smokeParticles: []
        };

        // ===== ARENA =====
        const arenaObjects = [];
        const navMeshObstacles = [];
        let gridHelper;

        function buildArena() {
            const size = CONFIG.arena.size;
            const wallHeight = CONFIG.arena.wallHeight;
            
            // Floor
            const floor = new THREE.Mesh(
                new THREE.PlaneGeometry(size, size),
                new THREE.MeshStandardMaterial({ color: 0x1a1a2a, metalness: 0.3, roughness: 0.7 })
            );
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);
            
            // Grid
            const gridMat = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    color1: { value: new THREE.Color(0x00ffff) },
                    color2: { value: new THREE.Color(0xff00ff) }
                },
                vertexShader: `
                    varying vec3 vPosition;
                    void main() {
                        vPosition = position;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform vec3 color1;
                    uniform vec3 color2;
                    varying vec3 vPosition;
                    void main() {
                        float pulse = sin(length(vPosition.xz) * 0.1 - time * 2.0) * 0.5 + 0.5;
                        gl_FragColor = vec4(mix(color1, color2, pulse), 0.3);
                    }
                `,
                transparent: true
            });
            gridHelper = new THREE.GridHelper(size, 30, 0x00ffff, 0x00ffff);
            gridHelper.position.y = 0.02;
            gridHelper.material = gridMat;
            scene.add(gridHelper);
            
            // Walls
            const wallMat = new THREE.MeshStandardMaterial({ color: 0x2a2a3a, metalness: 0.5, roughness: 0.5 });
            const wallPositions = [
                { pos: [0, wallHeight/2, -size/2], rot: [0, 0, 0], size: [size, wallHeight, 1] },
                { pos: [0, wallHeight/2, size/2], rot: [0, 0, 0], size: [size, wallHeight, 1] },
                { pos: [-size/2, wallHeight/2, 0], rot: [0, Math.PI/2, 0], size: [size, wallHeight, 1] },
                { pos: [size/2, wallHeight/2, 0], rot: [0, Math.PI/2, 0], size: [size, wallHeight, 1] }
            ];
            
            wallPositions.forEach((w, i) => {
                const wall = new THREE.Mesh(new THREE.BoxGeometry(...w.size), wallMat);
                wall.position.set(...w.pos);
                wall.rotation.set(...w.rot);
                wall.receiveShadow = true;
                wall.castShadow = true;
                scene.add(wall);
                arenaObjects.push({ mesh: wall, box: new THREE.Box3().setFromObject(wall) });
                
                const edge = new THREE.Mesh(
                    new THREE.BoxGeometry(w.size[0], 0.2, 0.1),
                    new THREE.MeshBasicMaterial({ color: [0x00ffff, 0xff00ff, 0xffff00, 0x00ff88][i] })
                );
                edge.position.set(w.pos[0], wallHeight + 0.1, w.pos[2]);
                edge.rotation.set(...w.rot);
                scene.add(edge);
            });
            
            // Center platform
            const centerPlatform = new THREE.Mesh(
                new THREE.BoxGeometry(10, 0.5, 10),
                new THREE.MeshStandardMaterial({ 
                    color: 0x3a1a2a, emissive: 0xff0044, emissiveIntensity: 0.1,
                    metalness: 0.6, roughness: 0.4
                })
            );
            centerPlatform.position.set(0, 0.25, 0);
            centerPlatform.receiveShadow = true;
            centerPlatform.castShadow = true;
            scene.add(centerPlatform);
            arenaObjects.push({ mesh: centerPlatform, box: new THREE.Box3().setFromObject(centerPlatform) });
            
            const centerBorder = new THREE.Mesh(
                new THREE.BoxGeometry(10.2, 0.1, 10.2),
                new THREE.MeshBasicMaterial({ color: 0xff3366 })
            );
            centerBorder.position.set(0, 0.52, 0);
            scene.add(centerBorder);
            
            // Platforms
            const platformMat = new THREE.MeshStandardMaterial({ color: 0x2a3a4a, metalness: 0.7, roughness: 0.3 });
            const platforms = [
                { pos: [15, 1.5, 15], size: [8, 3, 8], accent: 0x00ffff },
                { pos: [-15, 1.5, -15], size: [8, 3, 8], accent: 0xff00ff },
                { pos: [15, 1.5, -15], size: [8, 3, 8], accent: 0xffff00 },
                { pos: [-15, 1.5, 15], size: [8, 3, 8], accent: 0x00ff88 },
                { pos: [0, 2, 20], size: [12, 4, 6], accent: 0x00aaff },
                { pos: [0, 2, -20], size: [12, 4, 6], accent: 0xff5500 }
            ];
            
            platforms.forEach(p => {
                const platform = new THREE.Mesh(new THREE.BoxGeometry(...p.size), platformMat);
                platform.position.set(...p.pos);
                platform.receiveShadow = true;
                platform.castShadow = true;
                scene.add(platform);
                arenaObjects.push({ mesh: platform, box: new THREE.Box3().setFromObject(platform) });
                navMeshObstacles.push({ x: p.pos[0], z: p.pos[2], width: p.size[0]/2 + 1, depth: p.size[2]/2 + 1 });
                
                const edge = new THREE.Mesh(
                    new THREE.BoxGeometry(p.size[0] + 0.2, 0.15, p.size[2] + 0.2),
                    new THREE.MeshBasicMaterial({ color: p.accent })
                );
                edge.position.set(p.pos[0], p.pos[1] + p.size[1]/2 + 0.08, p.pos[2]);
                scene.add(edge);
            });
            
            // Ramps
            const rampMat = new THREE.MeshStandardMaterial({ color: 0x3a4a3a, metalness: 0.5, roughness: 0.5 });
            const ramps = [
                { pos: [15, 0.75, 10], rot: [0.3, 0, 0], size: [4, 0.3, 6] },
                { pos: [-15, 0.75, -10], rot: [-0.3, 0, 0], size: [4, 0.3, 6] },
                { pos: [10, 0.75, -15], rot: [0, 0, 0.3], size: [6, 0.3, 4] },
                { pos: [-10, 0.75, 15], rot: [0, 0, -0.3], size: [6, 0.3, 4] },
                { pos: [0, 1, 15], rot: [0.4, 0, 0], size: [6, 0.3, 6] },
                { pos: [0, 1, -15], rot: [-0.4, 0, 0], size: [6, 0.3, 6] }
            ];
            
            ramps.forEach(r => {
                const ramp = new THREE.Mesh(new THREE.BoxGeometry(...r.size), rampMat);
                ramp.position.set(...r.pos);
                ramp.rotation.set(...r.rot);
                ramp.receiveShadow = true;
                ramp.castShadow = true;
                scene.add(ramp);
                arenaObjects.push({ mesh: ramp, box: new THREE.Box3().setFromObject(ramp) });
            });
            
            // Cover
            const coverMat = new THREE.MeshStandardMaterial({ color: 0x4a3a2a, metalness: 0.4, roughness: 0.6 });
            const covers = [
                { pos: [8, 0.75, 0], size: [2, 1.5, 2] },
                { pos: [-8, 0.75, 0], size: [2, 1.5, 2] },
                { pos: [0, 0.75, 8], size: [2, 1.5, 2] },
                { pos: [0, 0.75, -8], size: [2, 1.5, 2] },
                { pos: [20, 0.75, 0], size: [3, 1.5, 3] },
                { pos: [-20, 0.75, 0], size: [3, 1.5, 3] },
                { pos: [0, 0.75, 22], size: [3, 1.5, 3] },
                { pos: [0, 0.75, -22], size: [3, 1.5, 3] }
            ];
            
            covers.forEach(c => {
                const cover = new THREE.Mesh(new THREE.BoxGeometry(...c.size), coverMat);
                cover.position.set(...c.pos);
                cover.receiveShadow = true;
                cover.castShadow = true;
                scene.add(cover);
                arenaObjects.push({ mesh: cover, box: new THREE.Box3().setFromObject(cover) });
                navMeshObstacles.push({ x: c.pos[0], z: c.pos[2], width: c.size[0]/2 + 0.5, depth: c.size[2]/2 + 0.5 });
            });
            
            // Pillars
            const pillarMat = new THREE.MeshStandardMaterial({ color: 0x3a3a4a, metalness: 0.8, roughness: 0.2 });
            const pillars = [[12, 0, 12], [-12, 0, 12], [12, 0, -12], [-12, 0, -12]];
            
            pillars.forEach((pos, i) => {
                const pillar = new THREE.Mesh(new THREE.CylinderGeometry(1, 1, 6, 8), pillarMat);
                pillar.position.set(pos[0], 3, pos[2]);
                pillar.receiveShadow = true;
                pillar.castShadow = true;
                scene.add(pillar);
                arenaObjects.push({ mesh: pillar, box: new THREE.Box3().setFromObject(pillar) });
                navMeshObstacles.push({ x: pos[0], z: pos[2], width: 1.5, depth: 1.5 });
                
                const ring = new THREE.Mesh(
                    new THREE.TorusGeometry(1.2, 0.1, 8, 16),
                    new THREE.MeshBasicMaterial({ color: [0x00ffff, 0xff00ff, 0xffff00, 0x00ff88][i] })
                );
                ring.position.set(pos[0], 5.5, pos[2]);
                ring.rotation.x = Math.PI / 2;
                scene.add(ring);
            });
        }

        // ===== ENEMIES =====
        const enemies = [];
        const enemyTypes = {
            grunt: { health: 50, speed: 4, damage: 10, fireRate: 1, accuracy: 0.15, color: 0x22c55e, score: 100 },
            soldier: { health: 80, speed: 5, damage: 15, fireRate: 2, accuracy: 0.1, color: 0xf59e0b, score: 200 },
            heavy: { health: 150, speed: 2.5, damage: 25, fireRate: 0.5, accuracy: 0.2, color: 0xef4444, score: 300 }
        };

        const spawnPoints = [
            new THREE.Vector3(25, 0, 25), new THREE.Vector3(-25, 0, 25),
            new THREE.Vector3(25, 0, -25), new THREE.Vector3(-25, 0, -25),
            new THREE.Vector3(25, 0, 0), new THREE.Vector3(-25, 0, 0),
            new THREE.Vector3(0, 0, 25), new THREE.Vector3(0, 0, -25)
        ];

        function createEnemy(type, position) {
            const typeData = enemyTypes[type];
            const group = new THREE.Group();
            
            const bodyMat = new THREE.MeshStandardMaterial({ 
                color: typeData.color, emissive: typeData.color, emissiveIntensity: 0.2,
                metalness: 0.3, roughness: 0.7
            });
            
            const body = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.5, 1.4, 8), bodyMat);
            body.position.y = 0.7;
            body.castShadow = true;
            group.add(body);
            
            const head = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.5), bodyMat.clone());
            head.position.y = 1.65;
            head.castShadow = true;
            group.add(head);
            
            const eyeMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const leftEye = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.12, 0.1), eyeMat);
            leftEye.position.set(-0.15, 1.7, 0.26);
            group.add(leftEye);
            const rightEye = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.12, 0.1), eyeMat);
            rightEye.position.set(0.15, 1.7, 0.26);
            group.add(rightEye);
            
            const gunGroup = new THREE.Group();
            gunGroup.add(new THREE.Mesh(
                new THREE.BoxGeometry(0.08, 0.08, 0.4),
                new THREE.MeshStandardMaterial({ color: 0x1a1a1a, metalness: 0.9, roughness: 0.3 })
            ).translateZ(0.3));
            
            const enemyMuzzle = new THREE.Mesh(
                new THREE.SphereGeometry(0.1, 8, 8),
                new THREE.MeshBasicMaterial({ color: 0xffaa00, transparent: true, opacity: 0 })
            );
            enemyMuzzle.position.z = 0.7;
            gunGroup.add(enemyMuzzle);
            gunGroup.position.set(0.3, 1.0, 0);
            group.add(gunGroup);
            
            const ring = new THREE.Mesh(
                new THREE.TorusGeometry(0.5, 0.05, 8, 16),
                new THREE.MeshBasicMaterial({ color: typeData.color, transparent: true, opacity: 0.5 })
            );
            ring.position.y = 0.7;
            ring.rotation.x = Math.PI / 2;
            group.add(ring);
            
            group.position.copy(position);
            scene.add(group);
            
            enemies.push({
                mesh: group, body, head, ring, muzzleFlash: enemyMuzzle, type,
                health: typeData.health, maxHealth: typeData.health,
                speed: typeData.speed, damage: typeData.damage,
                fireRate: typeData.fireRate, accuracy: typeData.accuracy,
                score: typeData.score, state: 'idle', lastShot: 0,
                velocity: new THREE.Vector3(),
                strafeDir: Math.random() > 0.5 ? 1 : -1, strafeTime: 0
            });
        }

        function updateEnemies(delta) {
            const playerPos = player.position.clone();
            playerPos.y = 1;
            
            enemies.forEach(enemy => {
                if (enemy.health <= 0) return;
                
                const enemyPos = enemy.mesh.position.clone();
                enemyPos.y = 1;
                const toPlayer = playerPos.clone().sub(enemyPos);
                const distance = toPlayer.length();
                
                enemy.mesh.lookAt(playerPos.x, enemy.mesh.position.y, playerPos.z);
                
                const rayDir = toPlayer.clone().normalize();
                const raycaster = new THREE.Raycaster(
                    new THREE.Vector3(enemy.mesh.position.x, 1.5, enemy.mesh.position.z), rayDir
                );
                
                const intersects = raycaster.intersectObjects(arenaObjects.map(o => o.mesh));
                const canSeePlayer = intersects.length === 0 || intersects[0].distance > distance;
                
                if (canSeePlayer && distance < 40) {
                    if (distance > 15) {
                        enemy.state = 'chase';
                        const moveDir = toPlayer.clone().normalize();
                        enemy.velocity.x = moveDir.x * enemy.speed;
                        enemy.velocity.z = moveDir.z * enemy.speed;
                    } else {
                        enemy.state = 'attack';
                        enemy.strafeTime += delta;
                        if (enemy.strafeTime > 2) {
                            enemy.strafeDir *= -1;
                            enemy.strafeTime = 0;
                        }
                        
                        const strafeVec = new THREE.Vector3(-toPlayer.z, 0, toPlayer.x).normalize();
                        enemy.velocity.x = strafeVec.x * enemy.speed * 0.5 * enemy.strafeDir;
                        enemy.velocity.z = strafeVec.z * enemy.speed * 0.5 * enemy.strafeDir;
                        
                        if (performance.now() - enemy.lastShot > 1000 / enemy.fireRate) {
                            enemyShoot(enemy);
                            enemy.lastShot = performance.now();
                        }
                    }
                } else {
                    enemy.state = 'idle';
                    enemy.velocity.x *= 0.9;
                    enemy.velocity.z *= 0.9;
                }
                
                const newPos = enemy.mesh.position.clone();
                newPos.x += enemy.velocity.x * delta;
                newPos.z += enemy.velocity.z * delta;
                
                const bounds = CONFIG.arena.size / 2 - 1;
                newPos.x = Math.max(-bounds, Math.min(bounds, newPos.x));
                newPos.z = Math.max(-bounds, Math.min(bounds, newPos.z));
                
                let blocked = false;
                navMeshObstacles.forEach(obs => {
                    if (Math.abs(newPos.x - obs.x) < obs.width && Math.abs(newPos.z - obs.z) < obs.depth) {
                        blocked = true;
                    }
                });
                
                if (!blocked) {
                    enemy.mesh.position.x = newPos.x;
                    enemy.mesh.position.z = newPos.z;
                }
                
                if (enemy.ring) enemy.ring.rotation.z += delta * 2;
                
                const healthRatio = enemy.health / enemy.maxHealth;
                const baseColor = new THREE.Color(enemyTypes[enemy.type].color);
                const currentColor = baseColor.clone().lerp(new THREE.Color(0x333333), 1 - healthRatio);
                enemy.body.material.color.copy(currentColor);
                enemy.body.material.emissive.copy(currentColor);
                enemy.body.material.emissiveIntensity = 0.2 * healthRatio;
                enemy.head.material.color.copy(currentColor);
                enemy.head.material.emissive.copy(currentColor);
            });
        }

        function enemyShoot(enemy) {
            if (enemy.muzzleFlash) {
                enemy.muzzleFlash.material.opacity = 1;
                setTimeout(() => { if (enemy.muzzleFlash) enemy.muzzleFlash.material.opacity = 0; }, 80);
            }
            
            const dir = new THREE.Vector3(0, 0, 1).applyQuaternion(enemy.mesh.quaternion);
            dir.x += (Math.random() - 0.5) * enemy.accuracy;
            dir.y += (Math.random() - 0.5) * enemy.accuracy;
            dir.normalize();
            
            const raycaster = new THREE.Raycaster(
                new THREE.Vector3(enemy.mesh.position.x, 1.5, enemy.mesh.position.z), dir
            );
            
            const playerBox = new THREE.Box3(
                new THREE.Vector3(player.position.x - 0.5, player.position.y - CONFIG.player.height, player.position.z - 0.5),
                new THREE.Vector3(player.position.x + 0.5, player.position.y + 0.2, player.position.z + 0.5)
            );
            
            if (raycaster.ray.intersectsBox(playerBox)) {
                playerTakeDamage(enemy.damage);
            }
        }

        function damageEnemy(enemy, damage, isHeadshot = false) {
            enemy.health -= (isHeadshot ? damage * 2 : damage) * player.damageMultiplier;
            spawnParticles(enemy.mesh.position.clone().add(new THREE.Vector3(0, 1, 0)), 0xef4444, 5);
            
            if (enemy.health <= 0) killEnemy(enemy);
        }

        function killEnemy(enemy) {
            const pos = enemy.mesh.position.clone();
            scene.remove(enemy.mesh);
            enemies.splice(enemies.indexOf(enemy), 1);
            
            gameState.kills++;
            gameState.score += enemy.score;
            
            spawnParticles(pos.clone().add(new THREE.Vector3(0, 1, 0)), enemyTypes[enemy.type].color, 15);
            
            if (Math.random() < 0.3) {
                const roll = Math.random();
                createPickup(roll < 0.4 ? 'ammo' : roll < 0.7 ? 'health' : 'armor', pos.clone().add(new THREE.Vector3(0, 0.5, 0)));
            }
            
            showHitmarker(true);
            updateHUD();
            
            if (enemies.length === 0 && gameState.waveInProgress) waveComplete();
        }

        // ===== WAVE SYSTEM =====
        function startWave() {
            gameState.waveInProgress = true;
            gameState.betweenWaves = false;
            
            const wave = gameState.wave;
            const shuffledSpawns = [...spawnPoints].sort(() => Math.random() - 0.5);
            let idx = 0;
            
            for (let i = 0; i < 3 + wave; i++) createEnemy('grunt', shuffledSpawns[idx++ % 8].clone());
            for (let i = 0; i < Math.floor(wave / 2); i++) createEnemy('soldier', shuffledSpawns[idx++ % 8].clone());
            for (let i = 0; i < Math.floor(wave / 3); i++) createEnemy('heavy', shuffledSpawns[idx++ % 8].clone());
            
            showMessage(`WAVE ${wave}`);
            updateHUD();
        }

        function waveComplete() {
            gameState.waveInProgress = false;
            gameState.betweenWaves = true;
            gameState.score += gameState.wave * 500;
            
            showMessage('WAVE CLEARED');
            spawnPickups();
            
            setTimeout(() => { gameState.wave++; startWave(); }, 3000);
        }

        // ===== PICKUPS =====
        const pickups = [];

        function spawnPickups() {
            createPickup('health', new THREE.Vector3((Math.random() - 0.5) * 40, 0.5, (Math.random() - 0.5) * 40));
            createPickup('ammo', new THREE.Vector3((Math.random() - 0.5) * 40, 0.5, (Math.random() - 0.5) * 40));
            createPickup('armor', new THREE.Vector3((Math.random() - 0.5) * 40, 0.5, (Math.random() - 0.5) * 40));
            
            if (player.health < CONFIG.player.maxHealth * 0.5) {
                createPickup('health', new THREE.Vector3((Math.random() - 0.5) * 30, 0.5, (Math.random() - 0.5) * 30));
            }
            
            const powerupTypes = ['damage', 'speed', 'rapid'];
            createPickup(powerupTypes[gameState.wave % 3], new THREE.Vector3((Math.random() - 0.5) * 20, 0.5, (Math.random() - 0.5) * 20));
        }

        function createPickup(type, position) {
            const configs = {
                health: { color: 0x22c55e, effect: () => { player.health = Math.min(CONFIG.player.maxHealth, player.health + 30); updateHUD(); }},
                ammo: { color: 0xf59e0b, effect: () => { weaponState.reserveAmmo = Math.min(WEAPON_CONFIG.reserveAmmo, weaponState.reserveAmmo + 30); updateHUD(); }},
                armor: { color: 0x3b82f6, effect: () => { player.armor = Math.min(CONFIG.player.maxArmor, player.armor + 50); updateHUD(); }},
                damage: { color: 0xef4444, effect: () => { player.powerup = 'damage'; player.powerupTimer = 10; player.damageMultiplier = 2; showPowerupIndicator('2X DAMAGE', 10); }},
                speed: { color: 0xa855f7, effect: () => { player.powerup = 'speed'; player.powerupTimer = 10; player.speedMultiplier = 1.5; showPowerupIndicator('SPEED BOOST', 10); }},
                rapid: { color: 0xec4899, effect: () => { player.powerup = 'rapid'; player.powerupTimer = 8; showPowerupIndicator('RAPID FIRE', 8); }}
            };
            
            const config = configs[type];
            const mesh = new THREE.Mesh(
                new THREE.BoxGeometry(0.8, 0.8, 0.8),
                new THREE.MeshStandardMaterial({ color: config.color, emissive: config.color, emissiveIntensity: 0.8, metalness: 0.5, roughness: 0.3 })
            );
            mesh.position.copy(position);
            
            const outline = new THREE.Mesh(
                new THREE.BoxGeometry(1.0, 1.0, 1.0),
                new THREE.MeshBasicMaterial({ color: config.color, transparent: true, opacity: 0.3, side: THREE.BackSide })
            );
            mesh.add(outline);
            scene.add(mesh);
            
            pickups.push({ mesh, effect: config.effect });
        }
        
        function showPowerupIndicator(text, duration) {
            const indicator = document.getElementById('powerup-indicator');
            indicator.textContent = text + ' (' + duration + 's)';
            indicator.style.opacity = 1;
        }
        
        function updatePowerups(delta) {
            if (player.powerupTimer > 0) {
                player.powerupTimer -= delta;
                const indicator = document.getElementById('powerup-indicator');
                const names = { damage: '2X DAMAGE', speed: 'SPEED BOOST', rapid: 'RAPID FIRE' };
                indicator.textContent = (names[player.powerup] || '') + ' (' + Math.ceil(player.powerupTimer) + 's)';
                
                if (player.powerupTimer <= 0) {
                    player.powerup = null;
                    player.damageMultiplier = 1;
                    player.speedMultiplier = 1;
                    indicator.style.opacity = 0;
                }
            }
        }

        function updatePickups() {
            pickups.forEach((pickup, index) => {
                pickup.mesh.rotation.y += 0.02;
                pickup.mesh.position.y = 0.5 + Math.sin(performance.now() * 0.003) * 0.1;
                
                if (player.position.distanceTo(pickup.mesh.position) < 1.5) {
                    pickup.effect();
                    scene.remove(pickup.mesh);
                    pickups.splice(index, 1);
                }
            });
        }

        // ===== PARTICLES =====
        const particles = [];

        function spawnParticles(position, color, count) {
            for (let i = 0; i < count; i++) {
                const mesh = new THREE.Mesh(
                    new THREE.BoxGeometry(0.1, 0.1, 0.1),
                    new THREE.MeshBasicMaterial({ color, transparent: true })
                );
                mesh.position.copy(position);
                scene.add(mesh);
                
                particles.push({
                    mesh,
                    velocity: new THREE.Vector3((Math.random() - 0.5) * 5, Math.random() * 5, (Math.random() - 0.5) * 5),
                    life: 1
                });
            }
        }

        function updateParticles(delta) {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.velocity.y -= 15 * delta;
                p.mesh.position.add(p.velocity.clone().multiplyScalar(delta));
                p.life -= delta * 2;
                p.mesh.material.opacity = p.life;
                
                if (p.life <= 0) {
                    scene.remove(p.mesh);
                    particles.splice(i, 1);
                }
            }
        }

        // ===== ENHANCED SHOOTING SYSTEM =====
        function shoot() {
            if (weaponState.isReloading) return;
            if (weaponState.currentMag <= 0) { tryReload(); return; }
            
            const now = performance.now();
            const fireRate = WEAPON_CONFIG.fireRate * (player.powerup === 'rapid' ? 2.5 : 1);
            if (now - weaponState.lastShotTime < 1000 / fireRate) return;
            
            // Reset burst if enough time passed
            if (weaponState.timeSinceLastShot > WEAPON_CONFIG.sprayPattern.resetTime) {
                weaponState.shotsFiredInBurst = 0;
            }
            
            weaponState.lastShotTime = now;
            weaponState.timeSinceLastShot = 0;
            weaponState.currentMag--;
            gameState.shotsFired++;
            
            // Calculate shot direction with spread and pattern
            const dir = calculateShotDirection();
            
            // Apply recoil
            applyRecoil();
            
            // Trigger effects
            triggerMuzzleFlash();
            triggerScreenEffects();
            spawnSmoke();
            
            weaponState.shotsFiredInBurst++;
            
            // Raycast
            const raycaster = new THREE.Raycaster(camera.position.clone(), dir);
            
            let hitEnemy = false;
            enemies.forEach(enemy => {
                if (enemy.health <= 0 || hitEnemy) return;
                
                for (const [part, isHead] of [[enemy.head, true], [enemy.body, false]]) {
                    const box = new THREE.Box3().setFromObject(part);
                    if (raycaster.ray.intersectsBox(box)) {
                        const intersect = new THREE.Vector3();
                        raycaster.ray.intersectBox(box, intersect);
                        const dist = camera.position.distanceTo(intersect);
                        
                        const obsIntersects = raycaster.intersectObjects(arenaObjects.map(o => o.mesh));
                        if (obsIntersects.length === 0 || obsIntersects[0].distance > dist) {
                            damageEnemy(enemy, WEAPON_CONFIG.damage, isHead);
                            hitEnemy = true;
                            gameState.shotsHit++;
                            
                            // Knockback
                            const knockDir = dir.clone().setY(0).normalize();
                            enemy.mesh.position.add(knockDir.multiplyScalar(0.15));
                            
                            showHitmarker(enemy.health <= 0);
                            return;
                        }
                    }
                }
            });
            
            if (!hitEnemy) {
                const intersects = raycaster.intersectObjects(arenaObjects.map(o => o.mesh));
                if (intersects.length > 0) {
                    const impact = new THREE.Mesh(
                        new THREE.PlaneGeometry(0.4, 0.4),
                        new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 1 })
                    );
                    impact.position.copy(intersects[0].point).add(intersects[0].face.normal.multiplyScalar(0.01));
                    impact.lookAt(intersects[0].point.clone().add(intersects[0].face.normal));
                    scene.add(impact);
                    
                    const fadeOut = setInterval(() => {
                        impact.material.opacity -= 0.05;
                        if (impact.material.opacity <= 0) { scene.remove(impact); clearInterval(fadeOut); }
                    }, 50);
                    
                    spawnParticles(intersects[0].point, 0xffaa00, 5);
                }
            }
            
            updateHUD();
        }
        
        function calculateShotDirection() {
            const dir = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
            
            // Calculate spread
            let spread = WEAPON_CONFIG.spread.base;
            const horizSpeed = Math.sqrt(player.velocity.x ** 2 + player.velocity.z ** 2);
            
            if (!player.onGround) {
                spread = WEAPON_CONFIG.spread.air;
            } else if (player.isSprinting) {
                spread = WEAPON_CONFIG.spread.sprint;
            } else if (horizSpeed > 1) {
                spread = WEAPON_CONFIG.spread.move;
            }
            
            spread += weaponState.currentBloom;
            
            // First shot accuracy
            if (weaponState.shotsFiredInBurst === 0) {
                spread *= WEAPON_CONFIG.spread.firstShotBonus;
            }
            
            // Spray pattern
            let patternPitch = 0, patternYaw = 0;
            if (WEAPON_CONFIG.sprayPattern.enabled) {
                const pattern = WEAPON_CONFIG.sprayPattern.pattern;
                const idx = Math.min(weaponState.shotsFiredInBurst, pattern.length - 1);
                const scale = WEAPON_CONFIG.sprayPattern.patternScale;
                
                patternPitch = pattern[idx][0] * scale;
                patternYaw = pattern[idx][1] * scale;
                
                if (weaponState.shotsFiredInBurst >= pattern.length) {
                    patternPitch += (Math.random() - 0.5) * 0.01;
                    patternYaw += (Math.random() - 0.5) * 0.015;
                }
            }
            
            // Apply offsets
            dir.x += (Math.random() - 0.5) * spread + patternYaw;
            dir.y += (Math.random() - 0.5) * spread - patternPitch;
            dir.normalize();
            
            // Add bloom
            weaponState.currentBloom = Math.min(
                WEAPON_CONFIG.spread.maxBloom,
                weaponState.currentBloom + WEAPON_CONFIG.spread.perShot
            );
            
            return dir;
        }
        
        function applyRecoil() {
            const cfg = WEAPON_CONFIG.recoil;
            
            const pitchKick = cfg.pitchAmount + (Math.random() - 0.5) * cfg.pitchRandom;
            const yawKick = (Math.random() - 0.5) * cfg.yawAmount + (Math.random() - 0.5) * cfg.yawRandom;
            
            weaponState.recoilPitch = Math.min(cfg.maxPitch, weaponState.recoilPitch + pitchKick);
            weaponState.recoilYaw = Math.max(-cfg.maxYaw, Math.min(cfg.maxYaw, weaponState.recoilYaw + yawKick));
            weaponState.recoilRecoveryTimer = cfg.recoveryDelay;
            
            weaponState.weaponKickZ = cfg.kickBackZ;
            weaponState.weaponKickRotX = cfg.kickRotationX * Math.PI / 180;
            
            weaponState.microShake.timer = cfg.shakeDuration;
            weaponState.microShake.x = (Math.random() - 0.5) * cfg.shakeIntensity;
            weaponState.microShake.y = (Math.random() - 0.5) * cfg.shakeIntensity;
        }
        
        function triggerMuzzleFlash() {
            const cfg = WEAPON_CONFIG.muzzle;
            
            const scale = cfg.flashScale.min + Math.random() * (cfg.flashScale.max - cfg.flashScale.min);
            muzzleFlash.scale.setScalar(scale);
            muzzleFlash.rotation.z = Math.random() * Math.PI * 2;
            muzzleFlash.material.opacity = 1;
            
            muzzleFlash2.scale.setScalar(scale * 0.7);
            muzzleFlash2.rotation.z = Math.random() * Math.PI * 2;
            muzzleFlash2.material.opacity = 0.8;
            
            muzzleLight.intensity = cfg.lightIntensity;
            
            setTimeout(() => {
                muzzleFlash.material.opacity = 0;
                muzzleFlash2.material.opacity = 0;
                muzzleLight.intensity = 0;
            }, cfg.flashDuration * 1000);
        }
        
        function triggerScreenEffects() {
            const cfg = WEAPON_CONFIG.screen;
            
            weaponState.fovPunch = Math.min(cfg.maxFovPunch, weaponState.fovPunch + cfg.fovPunch);
            weaponState.cameraShake.intensity = Math.max(weaponState.cameraShake.intensity, cfg.shakeIntensity);
            weaponState.chromaIntensity = Math.min(cfg.maxChroma, weaponState.chromaIntensity + cfg.chromaIntensity);
        }
        
        function spawnSmoke() {
            const cfg = WEAPON_CONFIG.muzzle;
            
            for (let i = 0; i < cfg.smokeParticles; i++) {
                const smoke = new THREE.Mesh(
                    new THREE.PlaneGeometry(0.08, 0.08),
                    new THREE.MeshBasicMaterial({
                        color: 0x888888,
                        transparent: true,
                        opacity: 0.4,
                        side: THREE.DoubleSide
                    })
                );
                
                const muzzleWorld = new THREE.Vector3();
                muzzleFlash.getWorldPosition(muzzleWorld);
                smoke.position.copy(muzzleWorld);
                
                const cameraDir = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
                smoke.userData.velocity = new THREE.Vector3(
                    cameraDir.x * cfg.smokeSpeed + (Math.random() - 0.5) * 2,
                    cameraDir.y * cfg.smokeSpeed + Math.random() * 1.5,
                    cameraDir.z * cfg.smokeSpeed + (Math.random() - 0.5) * 2
                );
                smoke.userData.life = cfg.smokeDuration;
                smoke.userData.maxLife = cfg.smokeDuration;
                
                scene.add(smoke);
                weaponState.smokeParticles.push(smoke);
            }
        }

        function tryReload() {
            if (weaponState.isReloading || weaponState.currentMag >= WEAPON_CONFIG.magSize || weaponState.reserveAmmo <= 0) return;
            
            weaponState.isReloading = true;
            document.getElementById('reload-indicator').style.opacity = 1;
            
            setTimeout(() => {
                const needed = WEAPON_CONFIG.magSize - weaponState.currentMag;
                const toReload = Math.min(needed, weaponState.reserveAmmo);
                weaponState.currentMag += toReload;
                weaponState.reserveAmmo -= toReload;
                weaponState.isReloading = false;
                document.getElementById('reload-indicator').style.opacity = 0;
                updateHUD();
            }, WEAPON_CONFIG.reloadTime * 1000);
        }

        // ===== PLAYER DAMAGE =====
        function playerTakeDamage(damage) {
            let remaining = damage;
            
            if (player.armor > 0) {
                const armorDmg = Math.min(player.armor, remaining * 0.5);
                player.armor -= armorDmg;
                remaining -= armorDmg * 2;
            }
            
            if (remaining > 0) player.health -= remaining;
            
            document.getElementById('damage-overlay').style.opacity = 0.5;
            setTimeout(() => { document.getElementById('damage-overlay').style.opacity = 0; }, 100);
            
            weaponState.cameraShake.intensity = Math.max(weaponState.cameraShake.intensity, 0.04);
            
            if (player.health <= 0) gameOver();
            updateHUD();
        }

        // ===== GAME FLOW =====
        function startGame() {
            document.getElementById('start-screen').style.display = 'none';
            
            gameState = {
                running: true, paused: false, wave: 1, score: 0, kills: 0,
                shotsFired: 0, shotsHit: 0, timeStarted: performance.now(),
                waveInProgress: false, betweenWaves: false
            };
            
            player.position.set(0, CONFIG.player.height, 0);
            player.velocity.set(0, 0, 0);
            player.health = CONFIG.player.maxHealth;
            player.armor = 0;
            player.stamina = CONFIG.player.maxStamina;
            player.powerup = null;
            player.powerupTimer = 0;
            player.damageMultiplier = 1;
            player.speedMultiplier = 1;
            player.coyoteTimer = 0;
            player.jumpBufferTimer = 0;
            
            // Reset weapon
            weaponState.currentMag = WEAPON_CONFIG.magSize;
            weaponState.reserveAmmo = WEAPON_CONFIG.reserveAmmo;
            weaponState.isReloading = false;
            weaponState.recoilPitch = 0;
            weaponState.recoilYaw = 0;
            weaponState.currentBloom = 0;
            weaponState.shotsFiredInBurst = 0;
            weaponState.fovPunch = 0;
            weaponState.cameraShake.intensity = 0;
            weaponState.chromaIntensity = 0;
            
            document.getElementById('powerup-indicator').style.opacity = 0;
            
            enemies.forEach(e => scene.remove(e.mesh));
            enemies.length = 0;
            pickups.forEach(p => scene.remove(p.mesh));
            pickups.length = 0;
            particles.forEach(p => scene.remove(p.mesh));
            particles.length = 0;
            
            // Initial pickups
            [[10, 10], [-10, 10], [10, -10], [-10, -10], [20, 0], [-20, 0], [0, 20], [0, -20]].forEach(([x, z], i) => {
                createPickup(['health', 'ammo', 'armor', 'health', 'ammo', 'health', 'armor', 'ammo'][i], new THREE.Vector3(x, 0.5, z));
            });
            
            updateHUD();
            renderer.domElement.requestPointerLock();
            setTimeout(() => startWave(), 1000);
        }

        function gameOver() {
            gameState.running = false;
            document.exitPointerLock();
            
            const time = (performance.now() - gameState.timeStarted) / 1000;
            const accuracy = gameState.shotsFired > 0 ? Math.round((gameState.shotsHit / gameState.shotsFired) * 100) : 0;
            
            document.getElementById('final-waves').textContent = gameState.wave;
            document.getElementById('final-kills').textContent = gameState.kills;
            document.getElementById('final-accuracy').textContent = accuracy;
            document.getElementById('final-time').textContent = `${Math.floor(time / 60)}:${Math.floor(time % 60).toString().padStart(2, '0')}`;
            document.getElementById('final-score').textContent = gameState.score;
            document.getElementById('game-over').style.display = 'flex';
        }

        // ===== HUD =====
        function updateHUD() {
            const healthBar = document.getElementById('health-bar');
            const healthPct = (player.health / CONFIG.player.maxHealth) * 100;
            healthBar.style.width = `${healthPct}%`;
            healthBar.style.background = healthPct > 60 ? 'linear-gradient(90deg, #22c55e, #4ade80)' :
                healthPct > 30 ? 'linear-gradient(90deg, #f59e0b, #fbbf24)' : 'linear-gradient(90deg, #ef4444, #f87171)';
            
            document.getElementById('armor-bar').style.width = `${(player.armor / CONFIG.player.maxArmor) * 100}%`;
            document.getElementById('stamina-bar').style.width = `${(player.stamina / CONFIG.player.maxStamina) * 100}%`;
            document.getElementById('low-health-overlay').style.opacity = healthPct < 30 ? 0.5 : 0;
            
            const ammoDisplay = document.getElementById('ammo-display');
            ammoDisplay.textContent = `${weaponState.currentMag} / ${weaponState.reserveAmmo}`;
            ammoDisplay.className = weaponState.currentMag === 0 ? 'empty' : weaponState.currentMag <= 5 ? 'low' : '';
            
            document.getElementById('wave-display').textContent = `WAVE ${gameState.wave}`;
            document.getElementById('enemies-remaining').textContent = `Enemies: ${enemies.length}`;
            
            const scoreDisplay = document.getElementById('score-display');
            if (gameState.score > (parseInt(scoreDisplay.textContent) || 0)) {
                scoreDisplay.classList.add('pop');
                setTimeout(() => scoreDisplay.classList.remove('pop'), 100);
            }
            scoreDisplay.textContent = gameState.score;
        }

        function updateCrosshair() {
            const size = (WEAPON_CONFIG.spread.base + weaponState.currentBloom) * 500;
            const gap = 4, length = 8, thickness = 2;
            
            const set = (id, w, h, l, t) => {
                const el = document.getElementById(id);
                el.style.width = `${w}px`;
                el.style.height = `${h}px`;
                el.style.left = `${l}px`;
                el.style.top = `${t}px`;
            };
            
            set('cross-top', thickness, length, -thickness/2, -size - length - gap);
            set('cross-bottom', thickness, length, -thickness/2, size + gap);
            set('cross-left', length, thickness, -size - length - gap, -thickness/2);
            set('cross-right', length, thickness, size + gap, -thickness/2);
        }

        function showHitmarker(isKill) {
            const hitmarker = document.getElementById('hitmarker');
            hitmarker.style.opacity = 1;
            hitmarker.style.transform = isKill ? 'translate(-50%, -50%) scale(1.5)' : 'translate(-50%, -50%) scale(1)';
            hitmarker.querySelector('svg').querySelectorAll('line').forEach(line => {
                line.setAttribute('stroke', isKill ? '#ef4444' : '#ffffff');
            });
            setTimeout(() => { hitmarker.style.opacity = 0; hitmarker.style.transform = 'translate(-50%, -50%) scale(1)'; }, 100);
        }

        function showMessage(text) {
            const display = document.getElementById('message-display');
            display.textContent = text;
            display.style.opacity = 1;
            setTimeout(() => { display.style.opacity = 0; }, 2000);
        }

        // ===== PLAYER UPDATE =====
        function updatePlayer(delta) {
            if (!gameState.running) return;
            
            player.prevVelocity.copy(player.velocity);
            
            const inputDir = new THREE.Vector3();
            if (keys['KeyW']) inputDir.z -= 1;
            if (keys['KeyS']) inputDir.z += 1;
            if (keys['KeyA']) inputDir.x -= 1;
            if (keys['KeyD']) inputDir.x += 1;
            
            const hasInput = inputDir.length() > 0;
            if (hasInput) {
                inputDir.normalize();
                const cos = Math.cos(player.rotation.y);
                const sin = Math.sin(player.rotation.y);
                const rotX = inputDir.x * cos + inputDir.z * sin;
                const rotZ = -inputDir.x * sin + inputDir.z * cos;
                inputDir.x = rotX;
                inputDir.z = rotZ;
            }
            
            const wantsToSprint = keys['ShiftLeft'] && hasInput && player.stamina > 0;
            player.isSprinting = wantsToSprint && player.onGround;
            
            if (player.isSprinting) {
                player.stamina -= CONFIG.player.staminaDrain * delta;
                if (player.stamina < 0) { player.stamina = 0; player.isSprinting = false; }
            } else {
                player.stamina = Math.min(CONFIG.player.maxStamina, player.stamina + CONFIG.player.staminaRegen * delta);
            }
            
            const baseSpeed = player.isSprinting ? CONFIG.player.sprintSpeed : CONFIG.player.walkSpeed;
            const targetSpeed = baseSpeed * player.speedMultiplier;
            
            const isGrounded = player.onGround;
            const accel = isGrounded ? CONFIG.player.groundAccel : CONFIG.player.airAccel;
            const decel = isGrounded ? CONFIG.player.groundDecel : CONFIG.player.airDecel;
            
            const horizVel = new THREE.Vector2(player.velocity.x, player.velocity.z);
            const currentSpeed = horizVel.length();
            
            if (hasInput) {
                const targetVel = new THREE.Vector2(inputDir.x * targetSpeed, inputDir.z * targetSpeed);
                
                if (isGrounded && currentSpeed > 1) {
                    const currentDir = horizVel.clone().normalize();
                    const inputDir2D = new THREE.Vector2(inputDir.x, inputDir.z);
                    const dot = currentDir.dot(inputDir2D);
                    
                    if (dot < -0.1) {
                        const brakeAmount = Math.min(currentSpeed, CONFIG.player.groundDecel * 1.5 * delta);
                        horizVel.multiplyScalar(1 - brakeAmount / currentSpeed);
                    }
                }
                
                const diff = targetVel.clone().sub(horizVel);
                const accelAmount = Math.min(diff.length(), accel * delta);
                if (accelAmount > 0.001) {
                    horizVel.add(diff.normalize().multiplyScalar(accelAmount));
                }
            } else {
                if (currentSpeed > 0.01) {
                    const friction = isGrounded ? CONFIG.player.friction : 1;
                    const decelAmount = Math.min(currentSpeed, decel * friction * delta);
                    horizVel.multiplyScalar(1 - decelAmount / currentSpeed);
                } else {
                    horizVel.set(0, 0);
                }
            }
            
            player.velocity.x = horizVel.x;
            player.velocity.z = horizVel.y;
            
            if (player.onGround) {
                player.coyoteTimer = CONFIG.player.coyoteTime;
                player.isJumping = false;
            } else {
                player.coyoteTimer = Math.max(0, player.coyoteTimer - delta);
            }
            player.jumpBufferTimer = Math.max(0, player.jumpBufferTimer - delta);
            
            const canJump = player.coyoteTimer > 0 || player.onGround;
            const wantsJump = player.jumpBufferTimer > 0;
            
            if (canJump && wantsJump) {
                player.velocity.y = CONFIG.player.jumpForce;
                player.onGround = false;
                player.coyoteTimer = 0;
                player.jumpBufferTimer = 0;
                player.isJumping = true;
                player.canCutJump = true;
                player.jumpLift = CONFIG.camera.jumpStretch;
            }
            
            player.velocity.y -= CONFIG.player.gravity * delta;
            
            const newPos = player.position.clone().add(player.velocity.clone().multiplyScalar(delta));
            
            const bounds = CONFIG.arena.size / 2 - 0.5;
            if (newPos.x < -bounds) { newPos.x = -bounds; player.velocity.x = 0; }
            if (newPos.x > bounds) { newPos.x = bounds; player.velocity.x = 0; }
            if (newPos.z < -bounds) { newPos.z = -bounds; player.velocity.z = 0; }
            if (newPos.z > bounds) { newPos.z = bounds; player.velocity.z = 0; }
            
            const playerRadius = 0.4;
            const stepHeight = CONFIG.player.stepHeight;
            let wasOnGround = player.onGround;
            player.onGround = false;
            
            arenaObjects.forEach(obj => {
                const box = obj.box;
                if (box.max.x - box.min.x > 50 || box.max.z - box.min.z > 50) return;
                
                const expandedMin = new THREE.Vector3(box.min.x - playerRadius, box.min.y, box.min.z - playerRadius);
                const expandedMax = new THREE.Vector3(box.max.x + playerRadius, box.max.y, box.max.z + playerRadius);
                
                if (newPos.x > expandedMin.x && newPos.x < expandedMax.x &&
                    newPos.z > expandedMin.z && newPos.z < expandedMax.z) {
                    
                    const playerBottom = newPos.y - CONFIG.player.height;
                    const playerTop = newPos.y + 0.2;
                    
                    if (playerBottom < box.max.y && playerTop > box.min.y) {
                        const heightDiff = box.max.y - (player.position.y - CONFIG.player.height);
                        
                        if (heightDiff > 0 && heightDiff <= stepHeight && player.velocity.y <= 0.1) {
                            newPos.y = box.max.y + CONFIG.player.height;
                            player.velocity.y = 0;
                            player.onGround = true;
                        } else if (player.position.y - CONFIG.player.height >= box.max.y - 0.1 && player.velocity.y <= 0) {
                            newPos.y = box.max.y + CONFIG.player.height;
                            player.velocity.y = 0;
                            player.onGround = true;
                        } else if (player.position.y + 0.2 <= box.min.y + 0.1 && player.velocity.y > 0) {
                            newPos.y = box.min.y - 0.2;
                            player.velocity.y = 0;
                        } else {
                            const centerX = (box.min.x + box.max.x) / 2;
                            const centerZ = (box.min.z + box.max.z) / 2;
                            const halfW = (box.max.x - box.min.x) / 2;
                            const halfD = (box.max.z - box.min.z) / 2;
                            
                            const overlapX = (halfW + playerRadius) - Math.abs(newPos.x - centerX);
                            const overlapZ = (halfD + playerRadius) - Math.abs(newPos.z - centerZ);
                            
                            if (overlapX < overlapZ) {
                                newPos.x = newPos.x < centerX ? box.min.x - playerRadius : box.max.x + playerRadius;
                                player.velocity.x = 0;
                            } else {
                                newPos.z = newPos.z < centerZ ? box.min.z - playerRadius : box.max.z + playerRadius;
                                player.velocity.z = 0;
                            }
                        }
                    }
                }
            });
            
            if (newPos.y <= CONFIG.player.height) {
                if (player.velocity.y < -3 && !wasOnGround) {
                    const impactStrength = Math.min(0.08, Math.abs(player.velocity.y) * 0.006);
                    player.landingImpact = impactStrength;
                    weaponState.cameraShake.intensity = Math.max(weaponState.cameraShake.intensity, impactStrength * 0.5);
                    spawnParticles(new THREE.Vector3(newPos.x, 0.1, newPos.z), 0x888888, 3);
                }
                
                newPos.y = CONFIG.player.height;
                player.velocity.y = 0;
                player.onGround = true;
            }
            
            player.position.copy(newPos);
        }

        function updateCamera(delta) {
            camera.position.copy(player.position);
            
            // Recoil recovery
            if (weaponState.recoilRecoveryTimer > 0) {
                weaponState.recoilRecoveryTimer -= delta;
            } else {
                const recoveryAmount = WEAPON_CONFIG.recoil.recoverySpeed * delta;
                weaponState.recoilPitch = Math.max(0, weaponState.recoilPitch - recoveryAmount);
                if (Math.abs(weaponState.recoilYaw) > 0.01) {
                    weaponState.recoilYaw *= (1 - recoveryAmount * 0.5);
                } else {
                    weaponState.recoilYaw = 0;
                }
            }
            
            // Weapon kickback recovery
            weaponState.weaponKickZ *= (1 - WEAPON_CONFIG.recoil.kickBackRecovery * delta);
            weaponState.weaponKickRotX *= (1 - WEAPON_CONFIG.recoil.kickBackRecovery * delta);
            
            // Micro-shake
            if (weaponState.microShake.timer > 0) {
                weaponState.microShake.timer -= delta;
                weaponState.microShake.x *= WEAPON_CONFIG.recoil.shakeDecay;
                weaponState.microShake.y *= WEAPON_CONFIG.recoil.shakeDecay;
            }
            
            // Camera shake
            if (weaponState.cameraShake.intensity > 0) {
                weaponState.cameraShake.x = (Math.random() - 0.5) * weaponState.cameraShake.intensity;
                weaponState.cameraShake.y = (Math.random() - 0.5) * weaponState.cameraShake.intensity;
                weaponState.cameraShake.intensity *= WEAPON_CONFIG.screen.shakeDecay;
                if (weaponState.cameraShake.intensity < 0.0001) weaponState.cameraShake.intensity = 0;
            }
            
            // Apply rotation with recoil
            camera.rotation.order = 'YXZ';
            camera.rotation.y = player.rotation.y + 
                weaponState.recoilYaw * Math.PI / 180 + 
                weaponState.microShake.x + 
                weaponState.cameraShake.x;
            camera.rotation.x = player.rotation.x - 
                weaponState.recoilPitch * Math.PI / 180 + 
                weaponState.microShake.y + 
                weaponState.cameraShake.y;
            
            // FOV with punch
            const baseFOV = player.isSprinting ? CONFIG.camera.sprintFOV : CONFIG.camera.baseFOV;
            const targetFOV = baseFOV + weaponState.fovPunch;
            weaponState.fovPunch = Math.max(0, weaponState.fovPunch - WEAPON_CONFIG.screen.fovPunchRecovery * delta);
            player.currentFOV += (targetFOV - player.currentFOV) * CONFIG.camera.fovLerpSpeed * delta;
            camera.fov = player.currentFOV;
            camera.updateProjectionMatrix();
            
            // Head bob
            const horizSpeed = Math.sqrt(player.velocity.x ** 2 + player.velocity.z ** 2);
            if (horizSpeed > 0.1 && player.onGround) {
                const bobMult = player.isSprinting ? 1.5 : 1;
                player.headBobTime += delta * CONFIG.camera.bobFrequency * bobMult;
                const speedRatio = horizSpeed / CONFIG.player.walkSpeed;
                camera.position.y += Math.sin(player.headBobTime) * CONFIG.camera.bobAmplitudeY * speedRatio;
                const sway = Math.cos(player.headBobTime * 0.5) * CONFIG.camera.bobAmplitudeX * speedRatio;
                camera.position.x += sway * Math.cos(player.rotation.y);
                camera.position.z += sway * Math.sin(player.rotation.y);
            } else if (player.onGround) {
                player.headBobTime += delta * CONFIG.camera.breathFrequency;
                camera.position.y += Math.sin(player.headBobTime) * CONFIG.camera.breathAmplitude;
            }
            
            // Landing/jump effects
            if (player.landingImpact > 0) {
                camera.position.y -= player.landingImpact;
                player.landingImpact *= 0.8;
                if (player.landingImpact < 0.001) player.landingImpact = 0;
            }
            if (player.jumpLift > 0) {
                camera.position.y += player.jumpLift;
                player.jumpLift *= 0.85;
                if (player.jumpLift < 0.001) player.jumpLift = 0;
            }
            
            // Weapon animation
            weaponState.weaponSwayX += mouse.deltaX * WEAPON_CONFIG.animation.swayAmount;
            weaponState.weaponSwayY += mouse.deltaY * WEAPON_CONFIG.animation.swayAmount;
            weaponState.weaponSwayX *= (1 - WEAPON_CONFIG.animation.swayRecovery * delta);
            weaponState.weaponSwayY *= (1 - WEAPON_CONFIG.animation.swayRecovery * delta);
            
            const targetSprint = player.isSprinting ? 1 : 0;
            weaponState.sprintBlend += (targetSprint - weaponState.sprintBlend) * WEAPON_CONFIG.animation.sprintLerpSpeed * delta;
            
            const targetReload = weaponState.isReloading ? 1 : 0;
            weaponState.reloadBlend += (targetReload - weaponState.reloadBlend) * WEAPON_CONFIG.animation.reloadLerpSpeed * delta;
            
            let targetX = WEAPON_CONFIG.animation.baseX - weaponState.weaponSwayX;
            let targetY = WEAPON_CONFIG.animation.baseY - weaponState.weaponSwayY;
            let targetZ = WEAPON_CONFIG.animation.baseZ;
            let targetRotX = 0;
            let targetRotZ = 0;
            
            // Weapon bob
            const bobX = Math.cos(player.headBobTime * 0.5) * CONFIG.camera.bobAmplitudeX * WEAPON_CONFIG.animation.bobInfluence;
            const bobY = Math.sin(player.headBobTime) * CONFIG.camera.bobAmplitudeY * WEAPON_CONFIG.animation.bobInfluence;
            targetX += bobX;
            targetY += bobY;
            
            // Kickback
            targetZ += weaponState.weaponKickZ;
            targetRotX -= weaponState.weaponKickRotX;
            
            // Sprint
            targetX += WEAPON_CONFIG.animation.sprintOffsetX * weaponState.sprintBlend;
            targetY += WEAPON_CONFIG.animation.sprintOffsetY * weaponState.sprintBlend;
            targetRotZ += WEAPON_CONFIG.animation.sprintRotZ * weaponState.sprintBlend;
            
            // Reload
            targetY -= WEAPON_CONFIG.animation.reloadDipY * weaponState.reloadBlend;
            targetRotX += WEAPON_CONFIG.animation.reloadRotX * weaponState.reloadBlend;
            
            const lerpSpeed = 15;
            weaponGroup.position.x += (targetX - weaponGroup.position.x) * lerpSpeed * delta;
            weaponGroup.position.y += (targetY - weaponGroup.position.y) * lerpSpeed * delta;
            weaponGroup.position.z += (targetZ - weaponGroup.position.z) * lerpSpeed * delta;
            weaponGroup.rotation.x += (targetRotX - weaponGroup.rotation.x) * lerpSpeed * delta;
            weaponGroup.rotation.z += (targetRotZ - weaponGroup.rotation.z) * lerpSpeed * delta;
            
            mouse.deltaX = 0;
            mouse.deltaY = 0;
        }
        
        function updateWeaponState(delta) {
            weaponState.timeSinceLastShot += delta;
            
            // Bloom recovery
            weaponState.currentBloom = Math.max(0, 
                weaponState.currentBloom - WEAPON_CONFIG.spread.bloomRecovery * delta
            );
            
            // Chromatic aberration decay
            weaponState.chromaIntensity *= WEAPON_CONFIG.screen.chromaDecay;
            if (weaponState.chromaIntensity < 0.0001) weaponState.chromaIntensity = 0;
            
            // Update chromatic aberration shader
            chromaPass.uniforms.amount.value = weaponState.chromaIntensity;
            chromaPass.uniforms.angle.value = Math.random() * Math.PI * 2;
            
            // Update smoke
            for (let i = weaponState.smokeParticles.length - 1; i >= 0; i--) {
                const smoke = weaponState.smokeParticles[i];
                
                smoke.position.add(smoke.userData.velocity.clone().multiplyScalar(delta));
                smoke.userData.velocity.y += delta * 2;
                smoke.userData.velocity.multiplyScalar(0.95);
                
                smoke.userData.life -= delta;
                const lifeRatio = smoke.userData.life / smoke.userData.maxLife;
                smoke.material.opacity = lifeRatio * 0.4;
                smoke.scale.setScalar(1 + (1 - lifeRatio) * 2);
                smoke.lookAt(camera.position);
                
                if (smoke.userData.life <= 0) {
                    scene.remove(smoke);
                    weaponState.smokeParticles.splice(i, 1);
                }
            }
        }

        // ===== MAIN LOOP =====
        let lastTime = performance.now();
        let gameTime = 0;

        function animate() {
            requestAnimationFrame(animate);
            
            const now = performance.now();
            const delta = Math.min((now - lastTime) / 1000, 0.1);
            lastTime = now;
            gameTime += delta;
            
            skyMat.uniforms.time.value = gameTime;
            if (gridHelper?.material?.uniforms) gridHelper.material.uniforms.time.value = gameTime;
            
            pointLights.forEach(pl => {
                pl.light.intensity = pl.baseIntensity * (Math.sin(gameTime * 2 + pl.phase) * 0.3 + 0.7);
            });
            
            if (gameState.running && !gameState.paused) {
                if (mouse.buttons[0]) shoot();
                
                updatePlayer(delta);
                updateCamera(delta);
                updateWeaponState(delta);
                updateEnemies(delta);
                updatePickups();
                updateParticles(delta);
                updatePowerups(delta);
                updateCrosshair();
                updateHUD();
            }
            
            composer.render();
        }

        // ===== INIT =====
        function init() {
            buildArena();
            
            document.getElementById('start-btn').addEventListener('click', startGame);
            document.getElementById('restart-btn').addEventListener('click', () => {
                document.getElementById('game-over').style.display = 'none';
                startGame();
            });
            document.getElementById('resume-btn').addEventListener('click', togglePause);
            document.getElementById('quit-btn').addEventListener('click', () => {
                document.getElementById('pause-menu').style.display = 'none';
                document.getElementById('start-screen').style.display = 'flex';
                gameState.running = false;
                gameState.paused = false;
                enemies.forEach(e => scene.remove(e.mesh));
                enemies.length = 0;
                pickups.forEach(p => scene.remove(p.mesh));
                pickups.length = 0;
            });
            
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                composer.setSize(window.innerWidth, window.innerHeight);
            });
            
            renderer.domElement.addEventListener('contextmenu', e => e.preventDefault());
            
            animate();
        }

        init();
    </script>
</body>
</html>